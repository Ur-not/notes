# 1.初识 Node.js
## 1.1 回顾与思考
### 1.1.2 浏览器中js的组成部分

![](https://gitee.com/ur-not/picture/raw/master/1.1.2.png)



### 1.1.3 为什么js可以在浏览器被执行
不同的浏览器使用不同的解析引擎

### 1.1.4 为什么js可以操作DOM和BOM
浏览器提供操作DOM和BOM的API


### 1.1.5 浏览器中的js运行环境
![](https://gitee.com/ur-not/picture/raw/master/1.1.5.png)

运行环境是指代码正常运行所需的必要环境。

V8引擎负责解析和执行JavaScript代码。
内置AP1是由运行环境提供的特殊接口，只能在所属的运行环境中被调用。

## 1.2 Node.js 简介
### 1.2.1 什么是Node.js
Node.js是一个基于Chrome V8引擎的js运行环境

### 1.2.2 Node.js中的js运行环境

![](https://gitee.com/ur-not/picture/raw/master/1.2.2.png)

浏览器是JS的前端运行环境
Node.js是JS的后端运行环境
Node.js中无法调用BOM和DOM等浏览器内置API

### 1.2.3Node.js可以做什么
Node.js作为一个JavaScript的运行环境，仅仅提供了基础的功能和APl。然而，基于Node.js提供的这些基础能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了Node.js，可以让前端程序员胜任更多的工作和岗位：

①基于Express框架（http://www.expressjs.com.cn/），可以快速构建Web应用

②基于Electron框架（https:/electronjs.org/），可以构建跨平台的桌面应用

③基于restify框架（http:/restify.com/），可以快速构建APl接口项目

④读写和操作数据库、创建实用的命令行工具辅助前端开发、etc.…

总之：Node.js是大前端时代的“大宝剑”，有了Node.js这个超级buff的加持，前端程序员的行业竞争力会越来越强！

## 1.3 Node.js 环境的安装
LTS为稳定版（推荐）       Current为新版

查看已安装的Node.js的版本号   node -v

什么是终端：为开发人员设计的 用于人机交互

## 1.4 在Node.js环境中执行JS代码
①打开终端 cmd 
②去往JS执行路径
cd空格路径 去往JS执行路径 / shift+右键打开cmd / 地址栏输入cmd
执行：node空格 文件名.js

快捷键：↑键定位上一次执行的命令
                 tab键 快速补全文件名 如node 文件名的第一个字+tab键
                 esc键快速清空当前已输的命令
                 cls清空上面已执行的所有历史

# 2.fs文件系统模块
## 2.1 什么是fs文件系统模块
fs模块是Node.js官方提供的、用来操作文件的模块。
它提供了一系列的方法和属性，用来满足用户对文件的操作需求例如：
● fs.readFile方法，用来读取指定文件中的内容
● fs.writeFile方法，用来向指定的文件中写入内容

如果要在JavaScript代码中，使用fs模块来操作文件，则需要使用如下的方式先导入它：
const fs = require（＇fs＇）

## 2.2 读取指定文件中的内容
### 2.2.1 fs.readFile()语法格式
使用fs.readFile方法，可以读取指定文件中的内容，语法格式如下：fs.readFile（path［，options］，callback）
参数解读：
●参数1：必选参数，字符串，表示文件的路径。
●参数：可选参数，表示以什么编码格式来读取文件。
●参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。

### 2.2.2 fs.readFile()的示例代码
fs.readFile()语法格式

```javascript
// 1. 导入 fs 模块，来操作文件
const fs = require('fs')

// 2. 调用 fs.readFile() 方法读取文件
//    参数1：读取文件的存放路径
//    参数2：读取文件时候采用的编码格式，一般默认指定 utf8
//    参数3：回调函数，拿到读取失败和成功的结果  err  dataStr
fs.readFile('./files/11.txt', 'utf8', function(err, dataStr) {
  // 2.1 打印失败的结果
  // 如果读取成功，则 err 的值为 null
  // 如果读取失败，则 err 的值为 错误对象，dataStr 的值为 undefined
  console.log(err)
  console.log('-------')
  // 2.2 打印成功的结果
  console.log(dataStr)
})
```



### 2.2.3 判断文件是否读取失败
err==null
```javascript
const fs = require('fs')

fs.readFile('./files/11.txt', 'utf8', function(err, dataStr) {
  if (err) {
    return console.log('读取文件失败！' + err.message)
  }
  console.log('读取文件成功！' + dataStr)
})
```


## 2.3 向指定文件中写入内容
### 2.3.1 fs.writeFile的语法格式
fs.writeFile(file,data[,options],callback)
参数解读：
●参数：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。
●参数2：必选参数，表示要写入的内容。
●参数3：可选参数，表示以什么格式写入文件内容，默认值是utf8。


### 2.3.2 fs.writeFile的示例代码
```javascript
fs.writeFile('./files/3.txt', 'ok123', function(err) {})
```

### 2.3.3 判断文件是否写入成功
err==null
```javascript
// 1. 导入 fs 文件系统模块
const fs = require('fs')

// 2. 调用 fs.writeFile() 方法，写入文件的内容
//    参数1：表示文件的存放路径
//    参数2：表示要写入的内容
//    参数3：回调函数
fs.writeFile('./files/3.txt', 'ok123', function(err) {
  // 2.1 如果文件写入成功，则 err 的值等于 null
  // 2.2 如果文件写入失败，则 err 的值等于一个 错误对象
  // console.log(err)

  if (err) {
    return console.log('文件写入失败！' + err.message)
  }
  console.log('文件写入成功！')
})
```

## 2.5 练习-整理考试成绩
核心实现步骤
①导入需要的fs文件系统模块
②使用fs.readFile方法，读取素材目录下的成绩.txt文件
③判断文件是否读取失败
④文件读取成功后，处理成绩数据
⑤将处理完成的成绩数据，调用fs.writeFile方法，写入到新文件ok.txt中

```javascript
// 1. 导入 fs 模块
const fs = require('fs')

// 2. 调用 fs.readFile() 读取文件的内容
fs.readFile('../素材/成绩.txt', 'utf8', function(err, dataStr) {
  // 3. 判断是否读取成功
  if (err) {
    return console.log('读取文件失败！' + err.message)
  }
  // console.log('读取文件成功！' + dataStr)

  // 4.1 先把成绩的数据，按照空格进行分割
  const arrOld = dataStr.split(' ')
  // 4.2 循环分割后的数组，对每一项数据，进行字符串的替换操作
  const arrNew = []
  arrOld.forEach(item => {
    arrNew.push(item.replace('=', '：'))
  })
  // 4.3 把新数组中的每一项，进行合并，得到一个新的字符串
  const newStr = arrNew.join('\r\n')

  // 5. 调用 fs.writeFile() 方法，把处理完毕的成绩，写入到新文件中
  fs.writeFile('./files/成绩-ok.txt', newStr, function(err) {
    if (err) {
      return console.log('写入文件失败！' + err.message)
    }
    console.log('成绩写入成功！')
  })
})
```

## 2.6 fs模块-路径动态拼接的问题
在使用fs模块操作文件时，如果提供的操作路径是以._或.._开头的相对路径时，很容易出现路径动态拼接错误的问题。
原因：代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径。
解决方法：
①read或write时使用完整的绝对路径,但是移植性比较差并且不利于后期维护
②使用\__dirname+相对路径
（path.join(\__dirname，'/files/1.txt'）
__dirname是执行的JS文件的路径

# 3.路径模块
## 3.1什么是path路径模块
path模块是Node.js官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。
例如：
●path.join方法，用来将多个路径片段拼接成一个完整的路径字符串
●path.basename0方法，用来从路径字符串中，将文件名解析出来

如果要在JavaScript代码中，使用path模块来处理路径，则需要使用如下的方式先导入它：
 const path = require（＇path＇）

## 3.2 路径拼接
### 3.2.1 path.join()语法格式
path.join([...path])

### 3.2.2 path.join()的代码示例
.._会抵消它前一层路径   .._../抵消两层
```javascript
const path = require('path')
const fs = require('fs')

// 注意：  ../ 会抵消前面的路径
// const pathStr = path.join('/a', '/b/c', '../../', './d', 'e')
// console.log(pathStr)  // \a\b\d\e

// fs.readFile(__dirname + '/files/1.txt')

fs.readFile(path.join(__dirname, './files/1.txt'), 'utf8', function(err, dataStr) {
  if (err) {
    return console.log(err.message)
  }
  console.log(dataStr)
})
```


## 3.3 获取路径中的文件名
### 3.3.1 path.basename()的语法样式
使用path.basename方法可以获取路径中的最后一部分,如文件名
path.basename(path[,ext])
参数解读
●path<string>必选参数，表示一个路径的字符串
●ext<string>可选参数，表示文件扩展名，加上这个参数表示仅获取名字，不包括格式后缀
●返回：<string>表示路径中的最后一部分

### 3.3.2 path.basename()的代码示例
```javascript
const path = require('path')

// 定义文件的存放路径
const fpath = '/a/b/c/index.html'

// const fullName = path.basename(fpath)
// console.log(fullName)

const nameWithoutExt = path.basename(fpath, '.html')
console.log(nameWithoutExt)
```

## 3.4 获取路径中的文件扩展名
### 3.4.1 path.extname()的语法格式
使用path.extname方法，可以获取路径中的扩展名部分，语法格式如下path.extname（path）
参数解读：
●path<string>必选参数，表示一个路径的字符串
●返回：<string>返回得到的扩展名字符串

### 3.4.1 path.extname()的代码示例
```javascript
const path = require('path')

// 这是文件的存放路径
const fpath = '/a/b/c/index.html'

const fext = path.extname(fpath)
console.log(fext)
```

## 3.5 综合案例-时钟
要求：将index.html拆分为css js html三个文件,并存入clock文件夹中

tip：使用正则表达式匹配style和script标签
/\<style>[\s\S]\*<\/style>/
/\<script>[\s\S]\*<\/script>/

\s：匹配任意的空白字符
\S：匹配任意的非空白字符
组合即为匹配任意的字符

exec：提取出符合正则的数值,以数组形式返回
replace（1，2）把①的内容换成②

```javascript
// 1.1 导入 fs 模块
const fs = require('fs')
// 1.2 导入 path 模块
const path = require('path')

// 1.3 定义正则表达式，分别匹配 <style></style> 和 <script></script> 标签
const regStyle = /<style>[\s\S]*<\/style>/
const regScript = /<script>[\s\S]*<\/script>/

// 2.1 调用 fs.readFile() 方法读取文件
fs.readFile(path.join(__dirname, '../素材/index.html'), 'utf8', function(err, dataStr) {
  // 2.2 读取 HTML 文件失败
  if (err) return console.log('读取HTML文件失败！' + err.message)
  // 2.3 读取文件成功后，调用对应的三个方法，分别拆解出 css, js, html 文件
  resolveCSS(dataStr)
  resolveJS(dataStr)
  resolveHTML(dataStr)
})

// 3.1 定义处理 css 样式的方法
function resolveCSS(htmlStr) {
  // 3.2 使用正则提取需要的内容
  const r1 = regStyle.exec(htmlStr)
  // 3.3 将提取出来的样式字符串，进行字符串的 replace 替换操作
  const newCSS = r1[0].replace('<style>', '').replace('</style>', '')
  // 3.4 调用 fs.writeFile() 方法，将提取的样式，写入到 clock 目录中 index.css 的文件里面
  fs.writeFile(path.join(__dirname, './clock/index.css'), newCSS, function(err) {
    if (err) return console.log('写入 CSS 样式失败！' + err.message)
    console.log('写入样式文件成功！')
  })
}

// 4.1 定义处理 js 脚本的方法
function resolveJS(htmlStr) {
  // 4.2 通过正则，提取对应的 <script></script> 标签内容
  const r2 = regScript.exec(htmlStr)
  // 4.3 将提取出来的内容，做进一步的处理
  const newJS = r2[0].replace('<script>', '').replace('</script>', '')
  // 4.4 将处理的结果，写入到 clock 目录中的 index.js 文件里面
  fs.writeFile(path.join(__dirname, './clock/index.js'), newJS, function(err) {
    if (err) return console.log('写入 JavaScript 脚本失败！' + err.message)
    console.log('写入 JS 脚本成功！')
  })
}

// 5.1 定义处理 HTML 结构的方法
function resolveHTML(htmlStr) {
  // 5.2 将字符串调用 replace 方法，把内嵌的 style 和 script 标签，替换为外联的 link 和 script 标签
  const newHTML = htmlStr.replace(regStyle, '<link rel="stylesheet" href="./index.css" />').replace(regScript, '<script src="./index.js"></script>')
  // 5.3 写入 index.html 这个文件
  fs.writeFile(path.join(__dirname, './clock/index.html'), newHTML, function(err) {
    if (err) return console.log('写入 HTML 文件失败！' + err.message)
    console.log('写入 HTML 页面成功！')
  })
}
```


# 4.http模块
## 4.1 什么是http模块
回顾：什么是客户端、什么是服务器？
在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。
http模块是Node.js官方提供的、用来创建web服务器的模块。通过http模块提供的http.createServer0方法，就能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web资源服务。
如果要希望使用http模块创建Web服务器，则需要先导入它：
 const http = require（＇http＇）

## 4.2 进一步理解http模块的作用
服务器和普通电脑的区别在于，服务器上安装了web服务器软件，例如：lIS、Apache等。通过安装这些服务器软件就能把一台普通的电脑变成一台web服务器。

在Node.js中，我们不需要使用lIS、Apache等这些第三方web服务器软件。因为我们可以基于Node.js提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务。

## 4.3 服务器相关的概念
### 4.3.1 IP地址
IP地址就是互联网上每台计算机的唯一地址，因此P地址具有唯一性。如果把“个人电脑”比作”一台电话”，那么“P地址”就相当于“电话号码”，只有在知道对方地址的前提下，才能与对应的电脑之间进行数据通信。
IP地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a，b，c，d都是0~255之间的十进制整数。例如：用点分十进表示的1P地址（192.168.1.1）

注意：
互联网中每台Web服务器，都有自己的lP地址，例如：大家可以在Windows的终端中运行ping www.baidu.com命令，即可查看到百度服务器的IP地址。
在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入127.0.0.1这个IP地址，就能把自己的电脑当做一台服务器进行访问了。

### 4.3.2 域名和域名服务器
尽管IP地址能够唯一地标记网络上的计算机，但P地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名（Domain Name）地址。
IP地址和域名是—一对应的关系，这份对应关系存放在一种叫做域名服务器（DNS，Domain name server）的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供地址和域名之间的转换服务的服务器。

注意：
①单纯使用地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。
②在开发测试期间，127.0.0.1对应的域名是localhost，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。

### 4.3.3 端口号
计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。
同样的道理，在一台电脑中，可以运行成百上千个web服务。每个web服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的web服务进行处理。

注意：
每个端口号不能同时被多个web服务占用。在实际应用中，URL中的80端口可以被省略。

## 4.4 创建最基本的web服务器
### 4.4.1 创建web服务器的基本步骤
①导入http模块
②创建web服务器实例
③为服务器实例绑定request事件，监听客户端的请求
④启动服务器

### 4.4.2 创建web服务器
```javascript
// 1. 导入 http 模块
const http = require('http')
// 2. 创建 web 服务器实例
const server = http.createServer()
// 3. 为服务器实例绑定 request 事件，监听客户端的请求
server.on('request', function (req, res) {
  console.log('Someone visit our web server.')
})
// 4. 启动服务器
server.listen(8080, function () {  
  console.log('server running at http://127.0.0.1:8080')
})
```

### 4.4.3 req请求对象
只要服务器接收到了客户端的请求，就会调用通过server.on为服务器绑定request事件处理函数。如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下的方式：
如客户端请求的URL地址 req.url
客户端的method请求类型 req.method

### 4.4.4 res响应
res.end（）
可以访问与服务器相关的数据和属性

### 4.4.5 解决中文乱码问题
res.setHeader('Contenr-Type'，'text/html:charset=utf-8')

## 4.5 根据不同的URL响应不同的html内容
### 4.5.1 核心实现步骤
①获取请求的url地址
②设置默认的响应内容为404 Not found
③判断用户请求的是否为_或_index.html,是则返回首页
④判断用户请求的是否为/about.html关于页面
⑤设置Content-Type响应头，防止中文乱码
⑥使用res.end把内容响应给客户端

### 4.5.2 动态响应内容代码
```javascript
const http = require('http')
const server = http.createServer()

server.on('request', (req, res) => {
  // 1. 获取请求的 url 地址
  const url = req.url
  // 2. 设置默认的响应内容为 404 Not found
  let content = '<h1>404 Not found!</h1>'
  // 3. 判断用户请求的是否为 / 或 /index.html 首页
  // 4. 判断用户请求的是否为 /about.html 关于页面
  if (url === '/' || url === '/index.html') {
    content = '<h1>首页</h1>'
  } else if (url === '/about.html') {
    content = '<h1>关于页面</h1>'
  }
  // 5. 设置 Content-Type 响应头，防止中文乱码
  res.setHeader('Content-Type', 'text/html; charset=utf-8')
  // 6. 使用 res.end() 把内容响应给客户端
  res.end(content)
})

server.listen(80, () => {
  console.log('server running at http://127.0.0.1')
})
```

## 4.6 实现clock时钟的web服务器案例
### 4.6.1 核心思路
把文件的实际存放路径作为每个资源的请求url地址

### 4.6.2 实现步骤
①导入需要的模块 http，fs，path
②创建基本的web服务器
③将资源的请求url地址映射为文件的存放路径
④读取文件内容并响应给客户端
⑤优化资源的请求路径

### 4.6.3 代码
```javascript
// 1.1 导入 http 模块
const http = require('http')
// 1.2 导入 fs 模块
const fs = require('fs')
// 1.3 导入 path 模块
const path = require('path')

// 2.1 创建 web 服务器
const server = http.createServer()
// 2.2 监听 web 服务器的 request 事件
server.on('request', (req, res) => {
  // 3.1 获取到客户端请求的 URL 地址
  //     /clock/index.html
  //     /clock/index.css
  //     /clock/index.js
  const url = req.url
  // 3.2 把请求的 URL 地址映射为具体文件的存放路径
  // const fpath = path.join(__dirname, url)
  // 5.1 预定义一个空白的文件存放路径
  let fpath = ''
  if (url === '/') {
    fpath = path.join(__dirname, './clock/index.html')
  } else {
    //     /index.html
    //     /index.css
    //     /index.js
    fpath = path.join(__dirname, '/clock', url)
  }

  // 4.1 根据“映射”过来的文件路径读取文件的内容
  fs.readFile(fpath, 'utf8', (err, dataStr) => {
    // 4.2 读取失败，向客户端响应固定的“错误消息”
    if (err) return res.end('404 Not found.')
    // 4.3 读取成功，将读取成功的内容，响应给客户端
    res.end(dataStr)
  })
})
// 2.3 启动服务器
server.listen(80, () => {
  console.log('server running at http://127.0.0.1')
})
```














































.



