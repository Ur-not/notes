# 1.模块化的基本概念
## 1.1 什么是模块化
模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。
编程领域的模块化就是遵循固定的规则，把一个大文件拆分成独立并互相依赖的多个小模块。
把代码就行模块化拆分的好处：
提供代码复用性和可维护性，并且可以实现按需加载。

## 1.2 模块化规范
模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。

例如：
使用什么样的语法格式来引用模块
在模块中使用什么样的语法格式向外暴露成员
模块化规范的好处：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。

# 2. Node.js中的模块化
## 2.1 Node.js中模块的分类
Node.js中根据模块来源的不同，将模块分为了3大类，分别是：
●内置模块（内置模块是由Node.js官方提供的，例如fs、path、http等）
●自定义模块（用户创建的每个j文件，都是自定义模块）
●第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）

## 2.2 加载模块
注意：加载自定义模块需要使用路径加载，并且可以省略后缀名

## 2.3 Node.js中的模块化
### 2.3.1 什么是模块作用域
和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。

### 2.3.2 模块作用域的好处
防止了全局变量勿扰的问题

## 2.4 向外共享模块作用域中的成员
### 2.4.1 module对象
在每个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息

### 2.4.2 module.exports对象
在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界使用。
外界使用require（）方法导入自定义模块时，得到的就是module.exports导出的对象

### 2.4.3 共享成员时的注意点
如果用module.exports.变量名=xx
又用module.exports = {键值对}指向一个新对象,则之前的导出失效,只导出新对象

#### 2.4.4 exports对象
由于module.exports单词写起来比较复杂，为了简化向外共享成员的代码，Node提供了exports对象。默认情况下，exports和module.exports指向同一个对象（===全等）。最终共享的结果，还是以module.exports指向的对象为准。

### 2.4.5 exports和module.exports的使用误区
 以module.exports={}指向的新对象为准,而exports={}指向的新对象不是
![](https://gitee.com/ur-not/picture/raw/master/2.4.4.png)

## 2.5 Node.js中的模块化规范
Node.js遵循了CommonJS模块化规范，CommonJS规定了模块的特性和各模块之间如何相互依赖。
CommonJS规定：
①每个模块内部，module变量代表当前模块。
②module变量是一个对象，它的exports属性（即module.exports）是对外的接口。
③加载某个模块，其实是加载该模块的module.exports属性。requireO方法用于加载模块。

# 3.npm与包
## 3.1 包
### 3.1.1 什么是包
Node.js中的第三方模块又叫做包

### 3.1.2 包的来源
包由第三方开发,免费使用

### 3.1.3 为什么需要包
包是基于内置模块封装出来的，提供了更高级、更方便的API，极大提高了开发效率

### 3.1.4 包的下载
www.npmjs.com
服务器：registry.npmjs.com

## 3.2 npm
### 3.2.1 格式化时间的传统做法
①创建格式化时间的自定义模块
②定义格式化时间的方法
③创建补零函数
④从自定义模块中导出格式化时间的函数⑤导入格式化时间的自定义模块
⑥调用格式化时间的函数

### 3.2.2 格式化时间的高级做法
①使用npm包管理工具，在项目中安装格式化时间的包moment
②使用require导入格式化时间的包
③参考moment的官方AP文档对时间进行格式化
const time = document.format('YYYY-MM-DD HH:mom:ss')

### 3.2.3 安装包
npm install 包名 / npm i 包名
npm i moment@2.22.2     @➕版本号 可以指定版本
包的语义化规范：
第一个是大版本，第二个是功能版本，第三个是bug修复版本
前面的版本改了,后面的版本号要归零

## 3.3 包管理配置文件
npm规定，在项目根目录中，必须提供一个叫做package.json的包管理配置文件。用来记录与项目有关的一些配置信息。
例如：
●项目的名称、版本号、描述等
●项目中都用到了哪些包（denpendencies）
●哪些包只在开发期间会用到
●哪些包在开发和部署时都需要用到

创建package.json：npm init -y
注意该项目文件夹的命名不要用中文和空格

根据package.json的denpendencies
使用npm install / npm i可以安装所有需要的包

npm uninstall 包名   可以卸载包
该包会在denpendencies中移除

如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到devDependencies节点中。与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到dependencies节点中。
您可以使用如下的命令，将包记录到devDependencies节点中：
安装指定的包，并记录到devDependencies节点中：npm i 包名 -D 
注意：上述命令是简写形式，等价于下面完整的写法：npm install 包名 --save-dev

查看当前包源：npm config get registry
切换npm包源到淘宝的镜像源：npm config set registry=https:registry.npm.taobao.org
也可以使用nrm来快速切换
首先安装nrm：npm i nrm -g
查看包源：nrm ls
切换到淘宝镜像源：nrm use taobao
切回官方包源：nrm use npm

## 3.5 包的分类
### 3.5.1 项目包
开发依赖包和核心依赖包

### 3.5.2 全局包
在执行npm install命令时，如果提供了－g参数，则会把包安装为全局包。
全局包会被安装到C:＼Users用户目录AppData＼Roaming＼Anpm＼node modules目录下。

npm i 包名 -g    全局安装指定的包
npm uninstall包名 -g 卸载全局安装的包

注意：
①只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。②判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。

### 3.5.3 i5ting_toc
安装 npm install -g i5ting_toc
在需要转换的md文件路径下运行cmd i5ting_toc -f  文件名.md(-o) （转换并打开转换后的html页面）
即可吧把md文件转换成html文件

## 3.6 规范的包结构
在清楚了包的概念、以及如何下载和使用包之后，接下来，我们深入了解一下包的内部结构。
一个规范的包，它的组成结构，必须符合以下3点要求：
①包必须以单独的目录而存在
②包的顶级目录下要必须包含package.json这个包管理配置文件
③package.json中必须包含name，version，main这三个属性，分别代表包的名字、版本号、包的入口。

注意：以上点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：https://yarnpkg.com/zh-Hans/docs/package-ison

## 3.7 开发属于自己的包
### 3.7.1 需要实现的功能
① 格式化日期
② 转义HTML中的特殊字符
③ 还原HTML中的特殊字符

### 3.7.2 初始化包的基本结构
①新建itheima-tools文件夹，作为包的根目录
②在itheima-tools文件夹中，新建如下三个文件：
●package.son（包管理配置文件）
●index.js（包的入口文件）
●README.md（包的说明文档）

### 3.7.3 初始化package.json

### 3.7.4 在index.js中定义格式化时间的方法

### 3.7.5 在index.js中定义转义HTML的方法

### 3.7.6 在index.js中定义还原HTML的方法

### 3.7.7 将不同的功能进行模块化拆分

### 3.7.8 编写包的说明文档

## 3.8 发布包
### 3.8.1 注册npm账号
①访问https:/www.npmjs.com/网站，点击sign up按钮，进入注册用户界面
②填写账号相关的信息：Full Name、Public Email、Username、Password
③点击Create an Account按钮，注册账号
④登录邮箱，点击验证链接，进行账号的验证

### 3.8.2 在终端登录npm账号
npm账号注册完成后，可以在终端中执行npm login命令，依次输入用户名、密码、邮箱后，即可登录成功。
注意：在运行npm login命令之前，必须先把下包的服务器地址切换为npm的官方服务器。否则会导致发布包失败！

npm login
Username：
Password：
Email：

### 3.8.3 把包分布到npm上
把终端切换到包的根目录后，运行npm public命令，即可将包发布到npm上（包名不能与已存的重名）

### 3.8.4 删除已发布的包
npm unpublish 包名 --force
只能删除72小时内发布的包
并且删除后24小时内不允许重复分布

# 4.模块的加载机制
## 4.1 优先从缓存中加载
模块在第一次加载后会被缓存。这也意味着多次调用require不会导致模块的代码被执行多次。
注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率

## 4.2 内置模块的加载机制
内置模块的加载优先级最高

## 4.3 自定义模块的加载机制
使用require加载自定义模块时，必须指定以_或_开头的路径标识符。在加载自定义模块时，如果没有指定./或.这样的路径标识符，则node会把它当作内置模块或第三方模块进行加载。

同时，在使用require()导入自定义模块时，如果省略了文件的扩展名，则Node.js会按顺序分别尝试加载以下的文件：
①按照确切的文件名进行加载
②补全js扩展名进行加载
③补全json扩展名进行加载
④补全.node扩展名进行加载
⑤加载失败，终端报错

## 4.4 第三方模块的加载机制
如果传递给require()的模块标识符不是一个内置模块，也没有以'./'或'../'开头，则Node.js会从当前模块的父目录开始，尝试从/node modules文件夹中加载第三方模块。

如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。
例如，假设在C:＼Users＼itheima＼project＼foo.js文件里调用了require（＇tools＇），则Node.js会按以下顺序查找：
①C:＼Users＇＼itheima＼project＼node modules＼tools
②C:＼Users＼itheima＼node modules＼tools
③C:＼Users＼node modules＼tools
④C:＼node modules＼tools

## 4.5 目录作为模块
当把目录作为模块标识符，传递给require()进行加载的时候，有三种加载方式：
①在被加载的目录下查找一个叫做package.json的文件，并寻找main属性，作为require()加载的入口
②如果目录里没有package.json文件，或者main入口不存在或无法解析，则Node.js将会试图加载目录下的index.js文件
③如果以上两步都失败了，则Node.js会在终端打印错误消息，报告模块的缺失：Error:Cannot find module ＇xxx

























,


![](1.%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/bear_sketch@2x.png)
