# 6.jQuery中的Ajax
## 6.1 了解jQuery中的Ajax
浏览器中提供的XMLHttpRequest用法比较复杂，所以jQuery对XMLHttpRequest进行了封装，提供了一系列Ajax相关的函数，极大地降低了Ajax的使用难度。

jQuery中发起Ajax请求最常用的三个方法如下：
·\$.get()
·\$.post()
·\$.ajax()

## 6.2 \$.get()函数的语法
jQuery中\$.get()函数的功能单一，专门用来发起get请求，从而将服务器上的资源请求到客户端来进行使用。\$.get()函数的语法如下：
\$get（ur1，［data］，［callback］）
其中，三个参数各自代表的含义如下：
|  参数名  | 参数类型 | 是否必选 |           说明           |
| :------: | :------: | :------: | :----------------------: |
|   url    |  string  |    是    |     要请求的资源地址     |
|   data   |  object  |    否    | 请求资源期间要携带的参数 |
| callback | function |    否    |   请求成功时的回调函数   |

### 6.2.1 \$.get()发起不带参数的请求
使用\$.get()函数发起不带参数的请求时，直接提供请求的URL地址和请求成功之后的回调函数即可，示例代码如下：
```javascript
$('#btnGET').on('click', function () {
   $.get('http://www.liulongbin.top:3006/api/getbooks', function (res) {
   console.log(res)
   })
})
```

### 6.2.2 \$.get()发起带参数的请求
```javascript
 $('#btnGETINFO').on('click', function () {
    $.get('http://www.liulongbin.top:3006/api/getbooks', { id: 1 }, function (res) {
      console.log(res)
    })
 })
```

## 6.3 \$.post()函数的语法
jQuery中\$.post()函数的功能单一，专门用来发起post请求，从而向服务器提交数据。\$.post()函数的语法如下：
\$post（url，［data］，［callback］）
其中，三个参数各自代表的含义如下：
参数名 参数类型 是否必选 说明
url string 是 提交数据的地址
data object 否 要提交的数据
callback function 否 数据提交成功时的回调函数


### 6.3.1 \$.post()向服务器提交数据
```javascript
$('#btnPOST').on('click', function () {
  $.ajax({
    type: 'POST',
    url: 'http://www.liulongbin.top:3006/api/addbook',
    data: {
      bookname: '史记',
      author: '司马迁',
      publisher: '上海图书出版社'
    },
    success: function (res) {
      console.log(res)
    }
  })
})
```

## 6.4 \$.ajax函数的语法
相比于\$.get()和\$.post()函数，jQuery中提供的\$.ajax()函数，是一个功能比较综合的函数，它允许我们对Ajax请求进行更详细的配置。
```JavaScript
$.ajax()函数的基本语法如下：
$.ajax({
type:'', //请求的方式，例如GET或Post
url:'', //请求的URL地址
data:{},//这次请求要携带的数据
success:function(res){}//请求成功之后的回调函数
})
```

### 6.4.1 使用\$.ajax发起GET请求
type设置为GET即可
```JavaScript
$.ajax({
type:'GET'，//请求的方式
ur1:'http://www.liulongbin.top:3006/api/getbooks',//请求的URL地址
data:{id:1},//这次请求要携带的数据
success:function(res){//请求成功之后的回调函数
console.log(res)
}）
```

### 6.4.2 使用\$.ajax发起POST请求
```JavaScript
$.ajax({
type:'POST'，//请求的方式
ur1:'http://www.liulongbin.top:3006/api/addbooks',//请求的URL地址
data:{//要提交给服务器的数据
bookname:'水浒传',
author:'施耐庵',
publisher:'上海图书出版社'
},
success:function(res){//请求成功之后的回调函数
console.log(res)
}})
```


# 7.接口
## 7.1 接口的概念
使用Ajax请求数据时，被请求的URL地址，就叫做数据接口（简称接口）。同时，每个接口必须有请求方式例如：
http://www.liulongbin.top:3006/api/getbooks获取图书列表的接口（GET请求）
http://www.liulongbin.top:3006/api/addbook添加图书的接口（post请求）

## 7.2 分析接口的请求过程
## 7.3 接口测试工具
### 7.3.1 什么是接口测试工具
为了验证接口能否被正常被访问，我们常常需要使用接口测试工具，来对数据接口进行检测。
好处：接口测试工具能让我们在不写任何代码的情况下，对接口进行调用和测试。

### 7.3.2 下载并安装PostMan

### 7.3.3 了解PostMan界面的组成部分


## 7.4 使用PostMan测试GET接口
步骤：
1.选择请求的方式
2.填写请求的URL地址
3.填写请求的参数(params)
4.点击Send按钮发起GET请求
5.查看服务器响应的结果

## 7.4 使用PostMan测试POST接口
步骤：
1.选择请求的方式
2.填写请求的URLU地址
3.选择Body面板并勾选数据格式
4.填写要发送到服务器的数据
5.点击Send按钮发起POST请求
6.查看服务器响应的结果

# 8.案例-图书管理
## 8.1 渲染UI结构

## 8.2 案例用到的库和插件
用到的css库bootstrap.css
用到的javascript库jquery.js
用到的vs code插件Bootstrap3 Snippets

- - - -
# 9.form表单的使用
## 9.1 什么是表单
表单在网页中主要负责数据采集功能。HTML中的<fom>标签，就是用于采集用户输入的信息，并通过<form>标签的提交操作，把采集到的信息提交到服务器端进行处理。

## 9.2 表单的组成部分
①表单标签
②表单域
③表单按钮
```JavaScript
<form>
 <input type="text" name="email or mobile"/>
 <input type="password" name="password"/>
 <input type="checkbox"name="remember me" checked />
 <button type="submit">提交</button>
</form>
```


## 9.3 <form>标签的属性
<fom>标签用来采集数据，<form>标签的属性则是用来规定如何把采集到的数据发送到服务器
![](https://gitee.com/ur-not/picture/raw/master/9.3.png)

### 9.3.1 action
action属性用来规定当提交表单时，向何处发送表单数据。
action属性的值应该是后端提供的一个URL地址，这个URL地址专门负责接收表单提交过来的数据。
当<form>表单在未指定action属性值的情况下，action的默认值为当前页面的URL地址(默认get提交）。
注意：当提交表单后，页面会立即跳转到action属性指定的URL地址

### 9.3.2 target
target属性原来规定在何处打开action URL
它的可选值有五个，默认情况下，target的值是_self，表示在相同的框架中(当前窗口)打开action URL，如果是_blank，表示在新窗口打开
![](https://gitee.com/ur-not/picture/raw/master/9.3.2.png)

### 9.3.3 method
method属性用来规定以何种方式把表单数据提交到action URL。
它的可选值有两个，分别是get和post。
默认情况下，method的值为get，表示通过URL地址的形式，把表单数据提交到action URL。

注意：
get方式适合用来提交少量的、简单的数据。
post方式适合用来提交大量的、复杂的、或包含文件上传的数据。
在实际开发中，<fom>表单的post提交方式用的最多，很少用get。例如登录、注册、添加数据等表单操作，都需要使用post方式来提交表单。

### 9.3.4 enctype
enctype属性用来规定在发送表单数据之前如何对数据进行编码。
它的可选值有三个，默认情况下，enctype的值为application/x-www-form-urlencoded，表示在发送前编码所有的字符。

① application/x-www-form-urlencoded
在发送前编码所有字符（默认）
② multipart/form-data
不对字符编码。
在使用包含**文件上传**控件的表单时，必须使用该值。
③ text/plain
空格转换为“+”加号，但不对特殊字符编码。（很少用）

## 9.4 表单的同步提交
### 9.4.1 什么是表单同步提交
通过submit按钮，触发表单提交的操作，从而使页面跳转到action URL的行为，叫做表单的同步提交

### 9.4.2 表单同步提交的缺点
①<form>表单同步提交后，整个页面会发生跳转，跳转到action URL所指向的地址，用户体验很差。
②<fom>表单同步提交后，页面之前的状态和数据会丢失。

### 9.4.3 如何解决表单同步提交的缺点
使用表单采集数据，ajax将数据提交到服务器

# 10.通过ajax提交表单数据
## 10.1 监听表单提交事件
```JavaScript
//方法①
$('#form1').submit (function(e){
alert('监听到了表单的提交事件')
})
//方法②
$('#form1').on('submit',function(e){
alert('监听到了表单的提交事件')
})
```

## 10.2 阻止表单默认提交行为
当监听到表单的提交事件以后，可以调用事件对象的event.preventDefaulto函数，来阻止表单的提交和页面的跳转，示例代码如下：
```JavaScript
//方法①
$('＃form1').submit(function(e){
//阻止表单的提交和页面的跳转
e.preventDefault()
})
//方法②
$('＃form1').on('submit',function(e){
//阻止表单的提交和页面的跳转
e.preventDefault()
})
```

## 10.3 快速获取表单中的数据
### 10.3.1 serialize()函数
为了简化表单中数据的获取操作，jQuery提供了serialize()函数，其语法格式如下：
\$(selector).serialize()
serialize() 函数的好处：可以一次性获取到表单中所有的数据

```JavaScript
<form id=＂form1＂>
 <input type=＂text＂name=＂username＂/>
 <input type=＂password＂name=＂password＂/>
 <button type=＂submit＂>提交</button>
</form>

$('#form1').serialize（）
//调用的结果：
//username=用户名的值＆password=密码的值
```

注意：在使用serialize()函数快速获取表单数据时，必须为每个表单元素添加name属性！

# 11.案例-评论列表
bootstrap：
class：form-control，btn，btn-primary，badge

列表组：bs3-list

join() 方法用于把数组转字符串。
元素是通过指定的分隔符进行分隔的。arrayObject.join(separator)， 默认为使用逗号分隔
var arr = ['a','b','c','d','e','f'];
arr.join('') abcdef
arr.join()  a,b,c,d,e,f
arr.join("-")  a-b-c-d-e-f

\$('')[0]：jQuery对象转DOM对象
\$('')[0].reset()：获取表单并转为DOM对象，然后调用DOM对象的reset方法，重置表单，清空输入值

# 12.模板引擎的基本概念
## 12.1 渲染UI结构时遇到的问题
通过字符串拼接来渲染UI结构，当UI结构比较复杂时，则拼接字符串的时候需要格外注意引号之前的嵌套，且一旦需求发生变化，修改起来也非常麻烦

## 12.2 什么是模板引擎
模板引擎可以感觉程序员提供的模板结构和数据，自动生成一个完整的HTML页面

## 12.3 模板引擎的好处
①减少了字符串的拼接操作
②使代码结构更清晰
③使代码更易于阅读和维护

# 13.art-template模板引擎
## 13.1 art-template模板引擎的基本使用
### 13.1.1使用传统方式渲染UI结构
```javascript
<body>
  <div id="title"></div>
  <div>姓名：<span id="name"></span></div>
  <div>年龄：<span id="age"></span></div>
  <div>会员：<span id="isVIP"></span></div>
  <div>注册时间：<span id="regTime"></span></div>
  <div>爱好：
    <ul id="hobby">
      <li>爱好1</li>
      <li>爱好2</li>
    </ul>
  </div>

  <script>
    var data = {
      title: '<h3>用户信息</h3>',
      name: 'zs',
      age: 20,
      isVIP: true,
      regTime: new Date(),
      hobby: ['吃饭', '睡觉', '打豆豆']
    }


    $(function () {
      $('#name').html(data.name)
      $('#title').html(data.title)
      $('#age').html(data.age)
      $('#isVIP').html(data.isVIP)
      $('#regTime').html(data.regTime)

      var rows = []
      $.each(data.hobby, function (i, item) {
        rows.push('<li>' + item + '</li>')
      })
      $('#hobby').html(rows.join(''))
    })
  </script>
</body>
```

### 13.1.2 art-template的使用步骤
① 导入art-template
script  src
② 定义数据
var data = {name:'zs',age:20}
③ 定义模板
```JavaScript
<script type="text/html">
{{name}} {{age}}
</script>
```
④ 调用template函数
var htmlstr = template('tpl',data)
⑤ 渲染HTML结构
使用jQuery或者原生JS将调用template函数的返回值渲染到页面
\$('\#container').html(htmlstr)
```javascript
<body>
  <div id="container"></div>
  <!-- 3. 定义模板 -->
  <!-- 3.1 模板的 HTML 结构，必须定义到 script 中 -->
  <script type="text/html" id="tpl-user">
    <h1>{{name}}    ------    {{age}}</h1>
    {{@ test}}

    <div>
      {{if flag === 0}}
      flag的值是0
      {{else if flag === 1}}
      flag的值是1
      {{/if}}
    </div>

    <ul>
      {{each hobby}}
      <li>索引是:{{$index}}，循环项是:{{$value}}</li>
      {{/each}}
    </ul>

    <h3>{{regTime}}</h3>
  </script>

  <script>
    // 2. 定义需要渲染的数据
    var data = { name: 'zs', age: 20, test: '<h3>测试原文输出</h3>', flag: 1, hobby: ['吃饭', '睡觉', '写代码'], regTime: new Date() }
    // 4. 调用 template 函数
    var htmlStr = template('tpl-user', data)
    console.log(htmlStr)
    // 5. 渲染HTML结构
    $('#container').html(htmlStr)
  </script>
</body>
```
## 13.2 art-template标准语法
### 13.2.1 什么是标准语法
art-template提供了｛｝这种语法格式，在｛｝内可以进行变量输出，或循环数组等操作，这种｛｝语法在art-template中被称为标准语法。

### 13.2.2 标准语法-输出
在{{ }}语法中,可以进行变量的蔬菜、对象属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出

### 13.2.3 标准语法-原文输出
如果要输出的value值中，包含了HTML标签结构，则需要使用原文输出语法，才能保证HTML标签被正常渲染
{{@ value }}
(这样就可以解析渲染HTML标签了)

### 13.2.4 标准语法-条件输出
如果要实现条件输出，则可以在{{ }}中使用if...else if.../if的方式，进行按需输出
{{ if 条件 }} 条件成立时输出的内容 {{ /if }}
{{ if 条件 }} 条件成立时输出的内容 {{ else if 条件 }} 条件成立时的内容 {{ /if }}

### 13.2.5 标准语法-循环输出
如果要实现循环输出，则可以在 {{ } }内，通过each语法循环数组，当前循环的索引|使用\$index进行访问，当前的循环项使用\$value进行访问。
{{ each arr }}
    {{ \$index }}  {{ \$value }}
{{ /each }}
注可以嵌套循环，此时的\$value内部和外部的值大概率不同（参考p70 八分半）
```JavaScript
data对象中的一个:  hobby：['吃饭','睡觉']
---------------------
<ul>
  {{each hobby}}
  <li>索引是：{{$index}}，循环项是：{{$value}}</li>
  {{each}}
</ul>
```

### 13.2.6 标准语法-过滤器
过滤器的本质就是一个function处理函数
{{ value | 自定义函数名 }}
{{ 值 | 处理函数 }} 值作为参数传给处理函数处理后返回新值 最终输出新值
template.defaults.imports.自定义函数名 = function (value) {
处理过程
return 最终值
}

## 13.3 案例-
split() 方法用于把字符串转成数组。stringObject.split(分隔符,数量)
分隔符：必需。
字符串或正则表达式，从该参数指定的地方分割字符串。
数量：可选。
该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。
```JavaScript
var str="Do you want to have a holiday?"
str.split(" ")  //  Do,you,want,to,have,a,holiday?
str.split(/\s+/)  //  Do,you,want,to,have,a,holiday? 正则表达式分割
str.split("") // D,o, ,y,o,u, ,w,a,n,t, ,t,o, ,h,a,v,e, ,a, ,h,o,l,i,d,a,y,?
str.split(" ",3) //  Do,you,want  3表示返回长度为3的数组

var str="Do-you-want-to-have-a-holiday?"
str.split("-") //  Do,you,want,to,have,a,holiday?
```

# 14.模板引擎的实现原理
## 14.1 正则与字符串操作
### 14.1.1 基本语法
exec函数用于检索字符串中的正则表达式的匹配。
如果字符串中有匹配的值，则返回该匹配值，否则返回ull。
RegExpobject.exec（string）

示例代码如下：
var str =＇hello＇
var pattern =_o_
console.log （pattern.exec（str））
输出的结果［＂o＂，index:4，input:＂hello＂，groups:undefined］

### 14.1.2 分组
正则表达式中()包起来的内容表示一个分组，可以通过分组来提取自己想要的内容，示例代码如下：
```JavaScript
var str = '<div>我是{{name}}</div>'
var pattern =/ {{ ( a-zA-Z) +) }} /

var patternResult = pattern.exec(str)
console.log(patternResult)
//得到name相关的分组信息
//［"{{Name}}","name",index:7,input:＂<div>我是{{name}}</div>＂，groups:undefined］
```

### 14.1.3 字符串的replace函数
replace()函数用于在字符串中用一些字符替换另一些字符，语法格式如下：
var result = '123456'.replace('123'，'abc'）得到的result的值为字符串'abc456'

示例代码如下：
```JavaScript
var str=＇<div>我是{{name}}</div>＇
var pattern /｛｛（［a-zA-Z］+）｝｝/
var patternResult = pattern.exec（str）
str=str.replace（patternResult[0].patternResult[1]）//replace函数返回值为替换后的新字符串
console.log(str）//输出的内容是：<div>我是name</div>
```

### 14.1.4 多次replace

### 14.1.5 使用while循环replace

### 14.1.6 replace替换为真值

## 14.2 实现简易的模板引擎
- - - -

# Ajax加强
# 15.XMLHttpRequest的基本使用
## 15.1 什么是XMLHttpRequest
XMLHttpRequest（简称xhr）是浏览器提供的Javascript对象，通过它，可以请求服务器上的数据资源。之前所学的jQuery中的Ajax函数，就是基于xhr对象封装出来的。

## 15.2 使用xhr发起GET请求
步骤：
① 创建xhr对象
② 调用xhr.open()函数
③ 调用xhr.send()函数
④ 监听xhr.onreadystatechange事件
```javascript
  // 1. 创建 XHR 对象
  var xhr = new XMLHttpRequest()
  // 2. 调用 open 函数
  xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks')
  // 3. 调用 send 函数
  xhr.send()
  // 4. 监听 onreadystatechange 事件
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      // 获取服务器响应的数据
      console.log(xhr.responseText)
    }
  }
```

## 15.3 了解xhr对象的readyState属性
XMLHttpRequest对象的readyState属性，用来表示当前Ajax请求所处的状态。每个Ajax请求必然处于以下状态中的一个

0：UNSENT
XMLHttpRequest对象已被创建，但尚未调用open方法。
1：OPENED
open() 方法已经被调用。
2：HEADERS RECEIVED
send()方法已经被调用，响应头也已经被接收。
3：LOADING
数据接收中，此时response属性中已经包含部分数据。
4：DONE
Ajax请求完成，这意味着数据传输已经彻底完成或失败。

## 15.4 使用xhr发起带参数的GET请求
使用xhr对象发起带参数的GET请求时，只需在调用xhr.open期间，为URL地址指定参数即可
xhr.open('GET','http://www.liulongbin.top:3006/api/getbooks?id=1')
这种在URL地址后面拼接的参数，叫做查询字符串。

## 15.5 查询字符串
### 15.5.1 什么是查询字符串
定义：查询字符串（URL参数）是指在URL的末尾加上用于向服务器发送信息的字符串（变量）。格式：将英文的 ? 放在URL的末尾，然后再加上参数=值，想加上多个参数的话，使用＆符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到URL中。
不带参数的URL地址
http://www.liulongbin.top:3006/api/getbooks
带一个参数的URL地址
http://www.liulongbin.top:3006/api/getbooks?id=1
带两个参数的URL地址
http://www.liulongbin.top:3006/api/getbooks?id=&bookname=西游记

### 15.5.2 GET请求携带参数的本质
无论使用\$.ajax0,还是使用\$.getO,又或者直接使用xhr对象发起GET请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形式，追加到URL地址的后面，发送到服务器的。
\$get ('url',{name:'zs',age:20},function (){}
等价于
\$get('url?name=zs&age=20',function(){}

\$ajax ({method:'GET',url:'url',data:{name:'zs',age:20},success:function(){}
等价于
\$ajax (method:'GET',url:'url？name=zs&age=20',success:function(){}

## 15.6 URL编码与解码
### 15.6.1 什么是URL编码
URL地址中，只允许出现英文相关的字母、标点符号、数字，因此，在URL地址中不允许出现中文字符。如果URL中需要包含中文这样的字符，则必须对中文字符进行编码（转义）。

URL编码的原则：使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。URL编码原则的通俗理解：使用英文字符去表示非英文字符。

http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=西游记

经过URL编码之后，URL地址变成了如下格式：
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0 (一个中文对应三个百分号)

### 15.6.2 如何对URL进行编码与解码
浏览器提供了URL编码与解码的API，分别是
encodeURI()  编码的函数
decodeURI()  解码的函数

encodeURI（＇黑马程序员＇）
输出字符串  %E9％BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F％E5%91%98
decodeURI ('%E9％BB%91%E9%A9%AC')
输出字符串 黑马

## 15.7 使用xhr发起POST请求
步骤：
① 创建xhr对象
② 调用xhr.open()函数
③ 设置Content-Type属性（固定写法）
④ 调用xhr.sendo函数，同时指定要发送的数据
⑤ 监听hr.onreadystatechange事件
```javascript
  // 1. 创建 xhr 对象
  var xhr = new XMLHttpRequest()
  // 2. 调用 open 函数
  xhr.open('POST', 'http://www.liulongbin.top:3006/api/addbook')
  // 3. 设置 Content-Type 属性
  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
  // 4. 调用 send 函数
  xhr.send('bookname=水浒传&author=施耐庵&publisher=上海图书出版社')
  // 5. 监听事件
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      console.log(xhr.responseText)
    }
  }
```

# 16.数据的交换格式
## 16.1 什么是数据交换格式
数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式。
前端领域，经常提及的两种数据交换格式分别是XML和JSON。其中XML用的非常少，所以，我们重点要学习的数据交换格式就是JSON。

## 16.2 XML
### 16.2.1 什么是XML
XML的英文全称是EXtensible Markup Language，即可扩展标记语言。因此，XML和HTML类似，也是一种标记语言。

### 16.2.2 XML和HTML的区别
XML和HTML虽然都是标记语言，但是，它们两者之间没有任何的关系。
●HTML被设计用来描述网页上的内容，是网页内容的载体
●XML被设计用来传输和存储数据，是数据的载体

### 16.2.3 XML的缺点
① XML 格式臃肿，和数据无关的代码多(标签)，体积大，传输效率低
② 在Javascript中解析XML比较麻烦

## 16.3 JSON
### 16.3.1 什么是JSON
概念：JSON的英文全称是JavaScript Object Notation，即＂JavaScript对象表示法”。简单来讲JSON就是Javascript对象和数组的字符串表示法，它使用文本表示一个JS对象或数组的信息，因此，JSON的本质是字符串。

作用：JO是一种轻量级的文本数据交换格式，在作用上类似于XML，专门用于存储和传输数据，但是JSON比XML更小、更快、更易解析。

现状：JSON是在2001年开始被推广和使用的数据格式，到现今为止，JSON已经成为了主流的数据交换格式。

### 16.3.2 JSON的两种结构
对象结构：对象结构在JSON中表示为｛｝括起来的内容。数据结构为｛key:value，key:value，…｝的键值对结构。其中，key必须是使用英文的双引|号包裹的字符串，value的数据类型可以是数字、字符串、布尔值、门ull、数组、对象6种类型。

数组结构：数组结构在JSON中表示为［］括起来的内容。数据结构为［＂java＂，＂javascript＂，30，true…］。数组中数据的类型可以是数字、字符串、布尔值、ull、数组、对象种类型

### 16.3.3 JSON语法注意事项
① 属性名必须使用双引号包裹
② 字符串类型的值必须使用双引号包裹
③ JSON中不允许使用单引号表示字符串
④ JSON中不能写注释
⑤ JSON的最外层必须是对象或数组格式
⑥ 不能使用undefined或函数作为JSON的值

JSON的作用：在计算机与网络之间存储和传输数据。
JSON的本质：用字符串来表示Javascript对象数据或数组数据

### 16.3.4 JSON和JS对象的关系
JSON是JS对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个字符串。
把一个JS对象用JSON的格式表示为一个字符串 
例如：这是一个对象
var obj =｛ a:＇Hello＇，b:＇World＇｝

这是一个JSON字符串，本质是一个字符串
var json =＇｛＂a＂:＂Hello＂，＂b＂:＂World＂｝＇

### 16.3.5 JSON和JS对象的互转
要实现从JSON字符串转换为JS对象，使用JSON.parse()方法：
var obj = JSON.parse('{＂a＂:＂Hello＂，＂b＂:＂World＂}')  结果是｛a:＇Hello＇，b:＇World＇｝

要实现从JS对象转换为JSON字符串，使用JSON.stringify()方法：
var json = JSON.stringify ({ a:＇Hello＇，b:＇World＇｝）结果是'{＂a＂:＂Hello＂，＂b＂:＂World＂｝

### 16.3.5 序列化和反序列化
把数据对象转换为字符串的过程，叫做序列化，例如：调用JSON.stringify()函数的操作，叫做JSON序列化。
把字符串转换为数据对象的过程，叫做反序列化，例如：调用JSON.parse()函数的操作，叫做JSON反序列化。

# 17.封装自己的Ajax
# 18.XMLHttpRequest Level2的新特性
## 18.1 认识XMLHttpRequest Level2
### 18.1.1 旧版XMLHttpRequest的缺点
① 只支持文本数据的传输，无法用来读取和上传文件
② 传送和接收数据时，没有进度信息，只能提示有没有完成

### 18.1.2 XMLHttpRequest Level2的新功能
① 可以设置HTTP请求的时限
② 可以使用FormData对象管理表单数据
③ 可以上传文件
④ 可以获得数据传输的进度信息

## 18.2 设置http请求时限
有时，Ajax操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的XMLHttpRequest对象，增加了timeout属性，可以设置HTTP请求的时限：
xhr.timeout = 3000

上面的语句，将最长等待时间设为3000毫秒。过了这个时限，就自动停止HTP请求。与之配套的还有一个timeout事件，用来指定回调函数：
xhr.ontimeout = function(event) {
alert('请求超时')
}


## 18.3 FormData对象管理表单数据
Ajax操作往往用来提交表单数据。为了方便表单处理，HTML新增了一个FormData对象，可以模拟表单操作：
```JavaScript
//1.新建FormData对象
var fd = new FormData()
//2.为FormData添加表单项
fd.append(＇uname＇，＇zs＇）
fd.append(＇upwd＇，＇123456＇）
//3.创建XHR对象
var xhr new XMLHttpRequest()
//4.指定请求类型与URL地址
xhr.open(＇POST＇，＇http://www.liulongbin.top:3006/api/formdata＇）
//5.直接提交FormData对象，这与提交网页表单的效果，完全一样
xhr.send（fd）
```

FormData对象也可以用来获取网页表单的值，示例代码如下：
```JavaScript
//获取表单元素
var form = document.querySelector ('#form1')
//监听表单元素的submit事件
form.addEventListener (submit',function(e){
  e.preventDefault()
  //根据form表单创建FormData对象，会自动将表单数据填充到FormData对象中
  var fd = new FormData(form)
  var xhr = new XMLHttpRequest()
  xhr.open('POST','http://www.liulongbin.top:3006/api/formdata')
  xhr.send(fd)
  xhr.onreadystatechange function(){}
})
```

## 18.4 上传文件
新版XMLHttpRequest对象，不仅可以发送文本信息，还可以上传文件。实现步骤：
① 定义UI结构
② 验证是否选择了文件
③ 向FormData中追加文件
④ 使用xhr发起上传文件的请求
⑤ 监听onreadystatechange事件
```javascript
<body>
  <!-- 1. 文件选择框 -->
  <input type="file" id="file1" />
  <!-- 2. 上传文件的按钮 -->
  <button id="btnUpload">上传文件</button>
  <br />
  <!-- 3. img 标签，来显示上传成功以后的图片 -->
  <img src="" alt="" id="img" width="800" />

  <script>
    // 1. 获取到文件上传按钮
    var btnUpload = document.querySelector('#btnUpload')
    // 2. 为按钮绑定单击事件处理函数
    btnUpload.addEventListener('click', function () {
      // 3. 获取到用户选择的文件列表
      var files = document.querySelector('#file1').files
      if (files.length <= 0) {
        return alert('请选择要上传的文件！')
      }
      var fd = new FormData()
      // 将用户选择的文件，添加到 FormData 中
      fd.append('avatar', files[0])

      var xhr = new XMLHttpRequest()
      xhr.open('POST', 'http://www.liulongbin.top:3006/api/upload/avatar')
      xhr.send(fd)

      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
          var data = JSON.parse(xhr.responseText)
          if (data.status === 200) {
            // 上传成功
            document.querySelector('#img').src = 'http://www.liulongbin.top:3006' + data.url
          } else {
            // 上传失败
            console.log('图片上传失败！' + data.message)
          }
        }
      }
    })
  </script>
</body>
```

## 18.5 显示文件上传进度
新版本的XMLHttpRequest对象中，可以通过监听xhr.upload.onprogress事件，来获取到文件的上传进度。语法格式如下：
```JavaScript
//创建XHR对象
var xhr = new XMLHttpRequest()
//监听xhr.upload的onprogress事件
xhr.upload.onprogress = function(e){
//e.lengthComputable是一个布尔值，表示当前上传的资源是否具有可计算的长度
  if(e.lengthComputable){
  //e.loaded 已传输的字节
  //e.total 需传输的总字节
    var percentComplete = Math.ceil((e.loaded/e.total）＊100）
   ｝
｝
```

bootsrap显示进度条：div class="progress-bar progress-bar-striped active"
class="progress-bar progress-bar-success"
```javascript
<body>
  <!-- 1. 文件选择框 -->
  <input type="file" id="file1" />
  <!-- 2. 上传文件的按钮 -->
  <button id="btnUpload">上传文件</button>

  <!-- bootstrap 中的进度条 -->
  <div class="progress" style="width: 500px; margin: 15px 10px;">
    <div class="progress-bar progress-bar-striped active" style="width: 0%" id="percent">
      0%
    </div>
  </div>

  <br />
  <!-- 3. img 标签，来显示上传成功以后的图片 -->
  <img src="" alt="" id="img" width="800" />

  <script>
    // 1. 获取到文件上传按钮
    var btnUpload = document.querySelector('#btnUpload')
    // 2. 为按钮绑定单击事件处理函数
    btnUpload.addEventListener('click', function () {
      // 3. 获取到用户选择的文件列表
      var files = document.querySelector('#file1').files
      if (files.length <= 0) {
        return alert('请选择要上传的文件！')
      }
      var fd = new FormData()
      // 将用户选择的文件，添加到 FormData 中
      fd.append('avatar', files[0])

      var xhr = new XMLHttpRequest()

      // 监听文件上传的进度
      xhr.upload.onprogress = function (e) {
        if (e.lengthComputable) {
          // 计算出上传的进度
          var procentComplete = Math.ceil((e.loaded / e.total) * 100)
          console.log(procentComplete)
          // 动态设置进度条
          $('#percent').attr('style', 'width: ' + procentComplete + '%;').html(procentComplete + '%')
        }
      }

      xhr.upload.onload = function () {
        $('#percent').removeClass().addClass('progress-bar progress-bar-success')
      }

      xhr.open('POST', 'http://www.liulongbin.top:3006/api/upload/avatar')
      xhr.send(fd)

      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
          var data = JSON.parse(xhr.responseText)
          if (data.status === 200) {
            // 上传成功
            document.querySelector('#img').src = 'http://www.liulongbin.top:3006' + data.url
          } else {
            // 上传失败
            console.log('图片上传失败！' + data.message)
          }
        }
      }
    })
  </script>
</body>
```

# 19.jQuery高级用法
## 19.1 jQuery实现文件上传
```javascript
  // 监听到Ajax请求被发起了
  $(document).ajaxStart(function () {
    $('#loading').show()
  })

  // 监听到 Ajax 完成的事件
  $(document).ajaxStop(function () {
    $('#loading').hide()
  })

  $('#btnUpload').on('click', function () {
    var files = $('#file1')[0].files
    if (files.length <= 0) {
      return alert('请选择文件后再上传！')
    }

    var fd = new FormData()
    fd.append('avatar', files[0])

    // 发起 jQuery 的 Ajax 请求，上传文件
    $.ajax({
      method: 'POST',
      url: 'http://www.liulongbin.top:3006/api/upload/avatar',
      data: fd,
      processData: false,
      contentType: false,
      success: function (res) {
        console.log(res)
      }
    })
  })
```

## 19.2 jQuery实现loading效果
### 19.2.1 ajaxStart(callback)
Ajax请求开始时，执行ajaxStart函数。可以在ajaxStart的callback中显示loading效果，示例代码如下：
自jQuery版本1.8起，该方法只能被附加到文档
\$(document).ajaxStart(function(){
  \$('# loading').show ()
})
注意：\$(document).ajaxStart()函数会监听当前文档内所有的Ajax请求

### 19.2.2 ajaxStop(callback)
Ajax请求结束时，执行ajaxStop函数。可以在ajaxStop的callback中隐藏loading效果，示例代码如下：
自jQuery版本1.8起，该方法只能被附加到文档
\$(document)..ajaxStop (function(){
  \$('# loading').hide()
})

# 20.axios
## 20.1 什么是axios
Axios是专注于网络数据请求的库。
相比于原生的XMLHttpRequest对象，axios简单易用。相比于jQuery，axios更加轻量化，只专注于网络数据请求。

## 20.2 axios发起GET请求
axios发起get请求的语法：
axios.get('url',{params:{_＊参数*_}}).then(callback)
具体的请求示例如下：
```JavaScript
//请求的URL地址
var url = 'http://www.liulongbin.top:3006/api/get'
//请求的参数对象
var paramsObj = { name:'zs',age:20 }
//调用axios.get()发起GET请求
axios.get (url,params:paramsObj}).then (function(res){
//res是axios包装后的响应数据
//res.data是服务器返回的数据
  var result = res.data
  console.log(res)
})
```


## 20.3 axios发起POST请求
axios发起post请求的语法：
axios.post('url',{_＊参数*_}).then(callback)
具体的请求示例如下：
```JavaScript
//请求的URL地址
var url ='http://www.liulongbin.top:3006/api/post'
//要提交到服务器的数据
var dataObj={ location:'北京'，address:'顺义'}
//调用axios.post()发起posT请求
axios.post(url,dataObj).then (function(res){
  //res.data是服务器返回的数据
  var result = res.data
  console.log(result)
})
```

## 20.4 直接使用axios.发起请求
axios也提供了类似于jQuery中\$.ajax(()的函数，语法如下：
```JavaScript
axis({
  method: '请求类型＇，
  url:＇请求的URL地址＇，
  data:｛/＊POST数据＊/｝，
  params:｛/＊GET参数＊/｝
}).then(callback）
```
```javascript
  //发起GET请求
  document.querySelector('#btn1').addEventListener('click', function () {
    var url = 'http://www.liulongbin.top:3006/api/get'
    var paramsObj = { name: 'zs', age: 20 }
    axios.get(url, { params: paramsObj }).then(function (res) {
      console.log(res.data)
    })
  })

  // 发起POST请求
  document.querySelector('#btn2').addEventListener('click', function () {
    var url = 'http://www.liulongbin.top:3006/api/post'
    var dataObj = { address: '北京', location: '顺义区' }
    axios.post(url, dataObj).then(function (res) {
      console.log(res.data)
    })
  })

  // 直接使用axios发起GET请求
  document.querySelector('#btn3').addEventListener('click', function () {
    var url = 'http://www.liulongbin.top:3006/api/get'
    var paramsData = { name: '钢铁侠', age: 35 }
    axios({
      method: 'GET',
      url: url,
      params: paramsData
    }).then(function (res) {
      console.log(res.data)
    })
  })

  // 直接使用axios发起POST请求
  document.querySelector('#btn4').addEventListener('click', function () {
    axios({
      method: 'POST',
      url: 'http://www.liulongbin.top:3006/api/post',
      data: {
        name: '娃哈哈',
        age: 18,
        gender: '女'
      }
    }).then(function (res) {
      console.log(res.data)
    })
  })
```

# 21.了解同源策略和跨域
## 21.1同源策略
### 21.1.1 什么是同源
如果两个页面的协议，域名和端口都相同，则两个页面具有相同的源

### 21.1.2 什么是同源策略
同源策略（英文全称Same origin policy）是浏览器提供的一个安全功能。

MDN官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

通俗的理解：浏览器规定，A网站的JavaScript，不允许和非同源的网站C之间，进行资源的交互，例如：
① 无法读取非同源网页的Cookie、LocalStorage和IndexedDB
② 无法接触非同源网页的DOM
③ 无法向非同源地址发送Ajax请求

## 21.2 跨域
### 21.2.1 什么是跨域
同源指的是两个URL的协议、域名、端口一致，反之，则是跨域。

出现跨域的根本原因：浏览器的同源策略不允许非同源的RL之间进行资源的交互。

网页：http://www.test.com/index.html
接口：http://www.api.com/userlist

### 21.2.2 浏览器对跨域请求的拦截
![](https://gitee.com/ur-not/picture/raw/master/21.2.2.png)
注意：浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器拦截，无法被页面获取到

### 21.2.3 如何实现跨域数据请求
现如今，实现跨域数据请求，最主要的两种解决方案，分别是JSONP和CORS。

JSONP:出现的早，兼容性好（兼容低版本IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。缺点是只支持GET请求，不支持POST请求。
CORS:出现的较晚，它是WC标准，属于跨域AjaX请求的根本解决方案。支持GET和POST请求。缺点是不兼容某些低版本的浏览器。

# 22.JSONP
## 22.1 什么是JSONP
JSONP（JSON with Padding）是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。

## 22.2 JSONP的实现原理
由于浏览器同源策略的限制，网页中无法通过Ajax请求非同源的接口数据。但是`<script>`标签不受浏览器同源策略的影响，可以通过src属性，请求非同源的js脚本。

因此，JSONP的实现原理，就是通过`<script`:标签的src属性，请求跨域的数据接口，并通过函数调用的形式，接收跨域接口响应回来的数据。

## 22.3自己实现一个简单的JSONP
```javascript
 <body>
    <script>
      function abc(data) {
        console.log('JSONP响应回来的数据是：')
        console.log(data)
      }
    </script>

    <!-- <script src="http://ajax.frontend.itheima.net:3006/api/jsonp?callback=abc&name=ls&age=30"></script> -->
    <script src="http://www.liulongbin.top:3006 /api/jsonp?callback=abc&name=ls&age=30"></script>
  </body>
```

## 22.4 JSONP的缺点
由于JSONP是通过`<script>`标签的src属性，来实现跨域数据获取的，所以，JSONP只支持GET数据请求，不支持POST请求。
注意：JSONP和Ajax之间没有任何关系，不能把JSONP请求数据的方式叫做AjaX，因为JSONP没有用到XMLHttpRequest这个对象。

## 22.5 jQuery中的JSONP
jQuery提供的\$.ajax()函数，除了可以发起真正的Ajax数据请求之外，还能够发起JSONP数据请求，例如：
```JavaScript
$.ajax({
  url:'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs＆age=20',
  //如果要使用$.ajax()发起JSONP请求，必须指定datatype为jsonp
  dataType :'jsonp',
  success:function(res){
    console.log(res)
  ｝
})
```
默认情况下，使用jQuery发起JSONP请求，会自动携带一个callback=jQueryxxx的参数，jQueryxxx是随机生成的一个回调函数名称。

## 22.6 jQuery自定义参数及回调函数名称
在使用jQuery发起JSONP请求时，如果想要自定义JSONP的参数以及回调函数名称，可以通过如下两个参数来指定：
```JavaScript
$.ajax（{
  url:'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs＆age=20',
  dataType:'jsonp',，
  //发送到服务端的参数名称，默认值为callback
  jsonp:'callback',
  //自定义的回调函数名称，默认值为jQueryxxx格式
  jsonpCallback:'abc',
  success:function(res){
    console.log(res)
   }
})
```

## 22.7 jQuery中JSONP的实现过程
jQuery中的JSONP，也是通过`<script>`标签的src属性实现跨域数据访问的，只不过，jQuery采用的是动态创建和移除`<script:>`标签的方式，来发起JSONP数据请求。

在发起JSONP请求的时候，动态向<header>中append一个`<script>`标签；
在JSONP请求成功以后，动态从<header>中移除刚才append进去的`<script>`标签；
































.









